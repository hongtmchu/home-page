<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="author" content="Hong T.M. Chu">
<meta name="description" content="Use tidyverse functions to correctly meld and pool multiply imputed model output.">
<title>Meld regression output from multiple imputations with tidyverse | Hong T.M. Chu – Hong T.M. Chu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../">
<link href="../../../../..//files/favicon-512.png" rel="icon" type="image/png">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting-17c909d5fd25ae21b861c0c7a49b2096.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap-5cd0811f461c8271ae6bab49df9501be.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../../../../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script src="../../../../../site_libs/quarto-contrib/iconify-2.0.0/iconify-icon.min.js"></script><script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-527449-5', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script><style>

      .quarto-title-block .quarto-title-banner {
        background: #170C3A;
      }
</style>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>
<meta property="og:title" content="Meld regression output from multiple imputations with tidyverse | Hong T.M. Chu">
<meta property="og:description" content="Use tidyverse functions to correctly meld and pool multiply imputed model output.">
<meta property="og:image" content="https://www.andrewheiss.com/files/profiles/twitter-card-large.png">
<meta property="og:site_name" content="Hong T.M. Chu">
<meta property="og:locale" content="en_US">
<meta property="og:image:height" content="1257">
<meta property="og:image:width" content="2401">
<meta name="twitter:title" content="Meld regression output from multiple imputations with tidyverse | Hong T.M. Chu">
<meta name="twitter:description" content="Use tidyverse functions to correctly meld and pool multiply imputed model output.">
<meta name="twitter:image" content="https://www.andrewheiss.com/files/profiles/twitter-card-large.png">
<meta name="twitter:creator" content="@andrewheiss">
<meta name="twitter:site" content="@andrewheiss">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="1257">
<meta name="twitter:image-width" content="2401">
</head>
<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner"><nav class="navbar navbar-expand-lg " data-bs-theme="dark"><div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../../index.html">
    <span class="navbar-title">Hong T.M. Chu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
<li class="nav-item">
    <a class="nav-link" href="../../../../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../cv/index.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../research/index.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../teaching/index.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
</ul>
<ul class="navbar-nav navbar-nav-scroll ms-auto">
<li class="nav-item">
    <a class="nav-link" href="mailto:hong.ctm@vinuni.edu.vn"> 
<span class="menu-text"><iconify-icon inline="" icon="bi:envelope" style="font-size: 1.1em;" aria-label="Icon envelope from bi Iconify.design set." title="E-mail"></iconify-icon></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/andrewheiss" rel="me"> 
<span class="menu-text"><iconify-icon inline="" icon="bi:github" style="font-size: 1.1em;" aria-label="Icon github from bi Iconify.design set." title="GitHub"></iconify-icon></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.linkedin.com/in/hongtmchu" rel="me"> 
<span class="menu-text"><iconify-icon inline="" icon="bi:linkedin" style="font-size: 1.1em;" aria-label="Icon linkedin from bi Iconify.design set." title="LinkedIn"></iconify-icon></span></a>
  </li>  
</ul>
</div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav></header><!-- content --><header id="title-block-header" class="quarto-title-block default blog-post page-columns page-full"><div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Meld regression output from multiple imputations with tidyverse</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                  <div>
        <div class="description">
          Use tidyverse functions to correctly meld and pool multiply imputed model output.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">r</div>
                <div class="quarto-category">imputation</div>
                <div class="quarto-category">tidyverse</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://www.andrewheiss.com/">Andrew Heiss</a> <a href="https://orcid.org/0000-0002-3948-3914" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Wednesday, March 7, 2018</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content"><p><span class="small">(<a href="https://github.com/andrewheiss/amelia-tidy-melding">See this notebook on GitHub</a>)</span></p>
<hr>
<p>Missing data can significantly influence the results of normal regression models, since the default in R and most other statistical packages is to throw away any rows with missing variables. To avoid unnecessarily throwing out data, it’s helpful to impute missing values. One of the best ways to do this is to build a separate regression model to make predictions that fill in the gaps in data. This isn’t always accurate, so it’s best to make many iterations of predictions (in imputation parlance, <span class="math inline">\(m\)</span> is the number of imputations done to a dataset). After making <span class="math inline">\(m\)</span> datasets, you can use this data by (1) running statistical tests on each imputation individually and then (2) pooling those results into a single number. The <a href="https://cran.r-project.org/web/packages/Amelia/vignettes/amelia.pdf">excellent Amelia vignette</a> details the theory and mechanics of how to use multiple imputation, and it’s a fantastic resource.</p>
<p>There are several packages for dealing with missing data in R, including <a href="https://cran.r-project.org/package=mi"><code>mi</code></a>, <a href="https://cran.r-project.org/package=mice"><code>mice</code></a>, and <a href="https://cran.r-project.org/package=Amelia"><code>Amelia</code></a>, and Thomas Leeper has <a href="http://thomasleeper.com/Rcourse/Tutorials/mi.html">a short overview of how to use all three</a>. I’m partial to <a href="https://gking.harvard.edu/amelia">Amelia</a>, since it’s designed to work well with time series-cross sectional data and can deal with complicated features like country-year observations.</p>
<p>Because Amelia is written by Gary King, et al., it works with <a href="https://zeligproject.org/">Zelig</a>, a separate framework that’s designed to simplify modeling in R. With Zelig + Amelia, you can combine all of the <span class="math inline">\(m\)</span> imputations automatically with whatever Zelig uses for printing model results. I’m not a huge fan of Zelig, though, and I prefer using <code><a href="https://rdrr.io/r/stats/lm.html">lm()</a></code>, <code><a href="https://rdrr.io/r/stats/glm.html">glm()</a></code>, <code>stan_glm()</code>, and gang on my own, thank you very much.</p>
<p>However, doing it on my own means there’s a little more work involved with combining coefficients and parameters across imputations. Fortunately, the <a href="https://www.tidyverse.org/">tidyverse</a>—specifically its ability to store models within data frames—makes it really easy to deal with models based on imputed data. Here’s how to do it using tidy functions. The code for this whole process can be greatly simplified in real life. You technically don’t need all these intermediate steps, though they’re helpful for seeing what’s going on behind the scenes.</p>
<p>We’ll start by working with some basic example imputed data frame from Amelia’s built-in data. We create 5 imputed datasets defining countries and years as cross sections and time series, and we log GDP per capita in the predictive model:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://gking.harvard.edu/amelia">Amelia</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://broom.tidymodels.org/">broom</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1234</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">africa</span><span class="op">)</span></span>
<span><span class="va">imp_amelia</span> <span class="op">&lt;-</span> <span class="fu">amelia</span><span class="op">(</span>x <span class="op">=</span> <span class="va">africa</span>, m <span class="op">=</span> <span class="fl">5</span>, cs <span class="op">=</span> <span class="st">"country"</span>, ts <span class="op">=</span> <span class="st">"year"</span>, </span>
<span>                     logs <span class="op">=</span> <span class="st">"gdp_pc"</span>, p2s <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting object contains a list of data frames, and each imputed dataset is stored in a list slot named “imputations” or <code>imp_amelia$imputations</code>. We can combine these all into one big data frame with <code>bind_rows()</code>, group by the imputation number (<span class="math inline">\(m\)</span>), and nest them into imputation-specific rows:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># unclass() is necessary because bind_rows() will complain when dealing with</span></span>
<span><span class="co"># lists with the "amelia" class, which is what amelia() returns</span></span>
<span><span class="va">all_imputations</span> <span class="op">&lt;-</span> <span class="fu">bind_rows</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/class.html">unclass</a></span><span class="op">(</span><span class="va">imp_amelia</span><span class="op">$</span><span class="va">imputations</span><span class="op">)</span>, .id <span class="op">=</span> <span class="st">"m"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">group_by</span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">nest</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">all_imputations</span></span>
<span><span class="co">## # A tibble: 5 × 2</span></span>
<span><span class="co">## # Groups:   m [5]</span></span>
<span><span class="co">##   m     data              </span></span>
<span><span class="co">##   &lt;chr&gt; &lt;list&gt;            </span></span>
<span><span class="co">## 1 imp1  &lt;tibble [120 × 7]&gt;</span></span>
<span><span class="co">## 2 imp2  &lt;tibble [120 × 7]&gt;</span></span>
<span><span class="co">## 3 imp3  &lt;tibble [120 × 7]&gt;</span></span>
<span><span class="co">## 4 imp4  &lt;tibble [120 × 7]&gt;</span></span>
<span><span class="co">## 5 imp5  &lt;tibble [120 × 7]&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With this nested data, we can use <code>purrr::map()</code> to run models and return tidy summaries of those models directly in the data frame:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">models_imputations</span> <span class="op">&lt;-</span> <span class="va">all_imputations</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span>model <span class="op">=</span> <span class="va">data</span> <span class="op">%&gt;%</span> <span class="fu">map</span><span class="op">(</span><span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">gdp_pc</span> <span class="op">~</span> <span class="va">trade</span> <span class="op">+</span> <span class="va">civlib</span>, data <span class="op">=</span> <span class="va">.</span><span class="op">)</span><span class="op">)</span>,</span>
<span>         tidied <span class="op">=</span> <span class="va">model</span> <span class="op">%&gt;%</span> <span class="fu">map</span><span class="op">(</span><span class="op">~</span> <span class="fu">tidy</span><span class="op">(</span><span class="va">.</span>, conf.int <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>,</span>
<span>         glance <span class="op">=</span> <span class="va">model</span> <span class="op">%&gt;%</span> <span class="fu">map</span><span class="op">(</span><span class="op">~</span> <span class="fu">glance</span><span class="op">(</span><span class="va">.</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">models_imputations</span></span>
<span><span class="co">## # A tibble: 5 × 5</span></span>
<span><span class="co">## # Groups:   m [5]</span></span>
<span><span class="co">##   m     data               model  tidied           glance           </span></span>
<span><span class="co">##   &lt;chr&gt; &lt;list&gt;             &lt;list&gt; &lt;list&gt;           &lt;list&gt;           </span></span>
<span><span class="co">## 1 imp1  &lt;tibble [120 × 7]&gt; &lt;lm&gt;   &lt;tibble [3 × 7]&gt; &lt;tibble [1 × 12]&gt;</span></span>
<span><span class="co">## 2 imp2  &lt;tibble [120 × 7]&gt; &lt;lm&gt;   &lt;tibble [3 × 7]&gt; &lt;tibble [1 × 12]&gt;</span></span>
<span><span class="co">## 3 imp3  &lt;tibble [120 × 7]&gt; &lt;lm&gt;   &lt;tibble [3 × 7]&gt; &lt;tibble [1 × 12]&gt;</span></span>
<span><span class="co">## 4 imp4  &lt;tibble [120 × 7]&gt; &lt;lm&gt;   &lt;tibble [3 × 7]&gt; &lt;tibble [1 × 12]&gt;</span></span>
<span><span class="co">## 5 imp5  &lt;tibble [120 × 7]&gt; &lt;lm&gt;   &lt;tibble [3 × 7]&gt; &lt;tibble [1 × 12]&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Having the models structured like this makes it easy to access coefficients for models from individual imputations, like so:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">models_imputations</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">m</span> <span class="op">==</span> <span class="st">"imp1"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">unnest</span><span class="op">(</span><span class="va">tidied</span><span class="op">)</span></span>
<span><span class="co">## # A tibble: 3 × 11</span></span>
<span><span class="co">## # Groups:   m [1]</span></span>
<span><span class="co">##   m     data     model  term     estim…¹ std.e…² stati…³  p.value conf.…⁴ conf.…⁵ glance  </span></span>
<span><span class="co">##   &lt;chr&gt; &lt;list&gt;   &lt;list&gt; &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;list&gt;  </span></span>
<span><span class="co">## 1 imp1  &lt;tibble&gt; &lt;lm&gt;   (Interc…   114.    97.7     1.17 2.44e- 1   -79.0   308.  &lt;tibble&gt;</span></span>
<span><span class="co">## 2 imp1  &lt;tibble&gt; &lt;lm&gt;   trade       18.1    1.25   14.4  9.65e-28    15.6    20.6 &lt;tibble&gt;</span></span>
<span><span class="co">## 3 imp1  &lt;tibble&gt; &lt;lm&gt;   civlib    -631.   182.     -3.46 7.47e- 4  -993.   -270.  &lt;tibble&gt;</span></span>
<span><span class="co">## # … with abbreviated variable names ¹​estimate, ²​std.error, ³​statistic, ⁴​conf.low,</span></span>
<span><span class="co">## #   ⁵​conf.high</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>More importantly, we can access the coefficients for all the models, which is essential for combining and averaging the coefficients across all five imputations.</p>
<p>Pooling or melding coefficients from many models is a little trickier than just averaging them all together (as delightfully easy as that would be). <a href="https://doi.org/10.1002/9780470316696">Donald Rubin (1987)</a> outlines an algorithm/set of rules for combining the results from multiply imputed datasets that reflects the averages and accounts for differences in standard errors. Rubin’s rules are essentially a fancier, more robust way of averaging coefficients and other quantities of interest across imputations.</p>
<p>Amelia has a built-in function for using Rubin’s rules named <code>mi.meld()</code> that accepts two m-by-k matrices (one for coefficients and one for standard errors) like so:</p>
<pre class="text"><code>      coef1  coef2  coefn
imp1  x      x      x
imp2  x      x      x
impn  x      x      x</code></pre>
<p>We can use some dplyr/tidyr magic to wrangle the regression results into this form:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Create a wide data frame of just the coefficients and standard errors</span></span>
<span><span class="va">params</span> <span class="op">&lt;-</span> <span class="va">models_imputations</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">unnest</span><span class="op">(</span><span class="va">tidied</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">m</span>, <span class="va">term</span>, <span class="va">estimate</span>, <span class="va">std.error</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">gather</span><span class="op">(</span><span class="va">key</span>, <span class="va">value</span>, <span class="va">estimate</span>, <span class="va">std.error</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">spread</span><span class="op">(</span><span class="va">term</span>, <span class="va">value</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">ungroup</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">params</span></span>
<span><span class="co">## # A tibble: 10 × 5</span></span>
<span><span class="co">##    m     key       `(Intercept)` civlib trade</span></span>
<span><span class="co">##    &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span><span class="co">##  1 imp1  estimate          114.   -631. 18.1 </span></span>
<span><span class="co">##  2 imp1  std.error          97.7   182.  1.25</span></span>
<span><span class="co">##  3 imp2  estimate          123.   -626. 18.0 </span></span>
<span><span class="co">##  4 imp2  std.error          96.8   181.  1.24</span></span>
<span><span class="co">##  5 imp3  estimate          114.   -633. 18.2 </span></span>
<span><span class="co">##  6 imp3  std.error          96.5   181.  1.24</span></span>
<span><span class="co">##  7 imp4  estimate          119.   -651. 18.2 </span></span>
<span><span class="co">##  8 imp4  std.error          95.4   180.  1.22</span></span>
<span><span class="co">##  9 imp5  estimate          132.   -648. 18.0 </span></span>
<span><span class="co">## 10 imp5  std.error          95.2   180.  1.22</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Extract just the coefficients</span></span>
<span><span class="va">just_coefs</span> <span class="op">&lt;-</span> <span class="va">params</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="st">"estimate"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="op">-</span><span class="va">m</span>, <span class="op">-</span><span class="va">key</span><span class="op">)</span></span>
<span><span class="va">just_coefs</span></span>
<span><span class="co">## # A tibble: 5 × 3</span></span>
<span><span class="co">##   `(Intercept)` civlib trade</span></span>
<span><span class="co">##           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span><span class="co">## 1          114.  -631.  18.1</span></span>
<span><span class="co">## 2          123.  -626.  18.0</span></span>
<span><span class="co">## 3          114.  -633.  18.2</span></span>
<span><span class="co">## 4          119.  -651.  18.2</span></span>
<span><span class="co">## 5          132.  -648.  18.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Extract just the standard errors</span></span>
<span><span class="va">just_ses</span> <span class="op">&lt;-</span> <span class="va">params</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="st">"std.error"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="op">-</span><span class="va">m</span>, <span class="op">-</span><span class="va">key</span><span class="op">)</span></span>
<span><span class="va">just_ses</span></span>
<span><span class="co">## # A tibble: 5 × 3</span></span>
<span><span class="co">##   `(Intercept)` civlib trade</span></span>
<span><span class="co">##           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span><span class="co">## 1          97.7   182.  1.25</span></span>
<span><span class="co">## 2          96.8   181.  1.24</span></span>
<span><span class="co">## 3          96.5   181.  1.24</span></span>
<span><span class="co">## 4          95.4   180.  1.22</span></span>
<span><span class="co">## 5          95.2   180.  1.22</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then use these matrices in <code>mi.meld()</code>, which returns a list with two slots—<code>q.mi</code> and <code>se.mi</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">coefs_melded</span> <span class="op">&lt;-</span> <span class="fu">mi.meld</span><span class="op">(</span><span class="va">just_coefs</span>, <span class="va">just_ses</span><span class="op">)</span></span>
<span><span class="va">coefs_melded</span></span>
<span><span class="co">## $q.mi</span></span>
<span><span class="co">##      (Intercept) civlib trade</span></span>
<span><span class="co">## [1,]         121   -638  18.1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $se.mi</span></span>
<span><span class="co">##      (Intercept) civlib trade</span></span>
<span><span class="co">## [1,]        96.7    181  1.24</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Armed with these, we can create our regression summary table with some more dplyr wizardry. To calculate the p-value and confidence intervals, we need to extract the degrees of freedom from one of the imputed models</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">model_degree_freedom</span> <span class="op">&lt;-</span> <span class="va">models_imputations</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">unnest</span><span class="op">(</span><span class="va">glance</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">m</span> <span class="op">==</span> <span class="st">"imp1"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">pull</span><span class="op">(</span><span class="va">df.residual</span><span class="op">)</span></span>
<span></span>
<span><span class="va">melded_summary</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">coefs_melded</span><span class="op">$</span><span class="va">q.mi</span><span class="op">)</span>,</span>
<span>                                      <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">coefs_melded</span><span class="op">$</span><span class="va">se.mi</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">magrittr</span><span class="fu">::</span><span class="fu">set_colnames</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"estimate"</span>, <span class="st">"std.error"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span>term <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html">rownames</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">term</span>, <span class="fu">everything</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span>statistic <span class="op">=</span> <span class="va">estimate</span> <span class="op">/</span> <span class="va">std.error</span>,</span>
<span>         conf.low <span class="op">=</span> <span class="va">estimate</span> <span class="op">+</span> <span class="va">std.error</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/TDist.html">qt</a></span><span class="op">(</span><span class="fl">0.025</span>, <span class="va">model_degree_freedom</span><span class="op">)</span>,</span>
<span>         conf.high <span class="op">=</span> <span class="va">estimate</span> <span class="op">+</span> <span class="va">std.error</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/TDist.html">qt</a></span><span class="op">(</span><span class="fl">0.975</span>, <span class="va">model_degree_freedom</span><span class="op">)</span>,</span>
<span>         p.value <span class="op">=</span> <span class="fl">2</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/TDist.html">pt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">statistic</span><span class="op">)</span>, <span class="va">model_degree_freedom</span>, lower.tail <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">melded_summary</span></span>
<span><span class="co">##                    term estimate std.error statistic conf.low conf.high  p.value</span></span>
<span><span class="co">## (Intercept) (Intercept)    120.6     96.67      1.25    -70.9     312.0 2.15e-01</span></span>
<span><span class="co">## civlib           civlib   -637.8    181.13     -3.52   -996.6    -279.1 6.13e-04</span></span>
<span><span class="co">## trade             trade     18.1      1.24     14.63     15.6      20.5 3.45e-28</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hooray! Correctly melded coefficients and standard errors!</p>
<p>But what do we do about the other model details, like <span class="math inline">\(R^2\)</span> and the F-statistic? How do we report those?</p>
<p>According to <a href="https://lists.gking.harvard.edu/pipermail/amelia/2016-July/001249.html">a post on the Amelia mailing list</a>, there are two ways. First, we can use a fancy method for combining <span class="math inline">\(R^2\)</span> and adjusted <span class="math inline">\(R^2\)</span> described by <a href="https://doi.org/10.1080/02664760802553000">Ofer Harel (2009)</a>. Second, we can just take the average of the <span class="math inline">\(R^2\)</span>s from all the imputed models. The results should be roughly the same.</p>
<p>Harel’s method involves two steps:</p>
<ol type="1">
<li>In each complete data set, calculate the <span class="math inline">\(R^2\)</span>, take its square root (<span class="math inline">\(R\)</span>), transform <span class="math inline">\(R\)</span> with a Fisher z-transformation (<span class="math inline">\(Q = \frac{1}{2} \log_{e}(\frac{1 + R}{1 - R})\)</span>), and calculate the variance of <span class="math inline">\(R^2\)</span> (which is <span class="math inline">\(\frac{1}{\text{degrees of freedom}}\)</span>)</li>
<li>Meld the resulting <span class="math inline">\(Q\)</span> and variance using Rubin’s rules (<code>mi.meld()</code>; this creates <span class="math inline">\(Q_a\)</span>), undo the z-transformation (<span class="math inline">\(R_a = (\frac{-1 + \exp(2Q_a)}{1 + \exp(2Q_a)})^2\)</span>), and square it (<span class="math inline">\(R_a^2\)</span>)</li>
</ol>
<p>That looks complicated, but it’s fairly easy with some dplyr magic. Here’s how to do it for adjusted <span class="math inline">\(R^2\)</span> (the same process works for regular <span class="math inline">\(R^2\)</span> too):</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Step 1: in each complete data set, calculate R2, take its square root,</span></span>
<span><span class="co"># transform it with Fisher z-transformation, and calculate the variance of R2\</span></span>
<span><span class="va">r2s</span> <span class="op">&lt;-</span> <span class="va">models_imputations</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">unnest</span><span class="op">(</span><span class="va">glance</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">m</span>, <span class="va">adj.r.squared</span>, <span class="va">df.residual</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span>R <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">adj.r.squared</span><span class="op">)</span>,  <span class="co"># Regular R</span></span>
<span>         Q <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="op">(</span><span class="va">R</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">R</span><span class="op">)</span><span class="op">)</span>,  <span class="co"># Fisher z-transformation</span></span>
<span>         se <span class="op">=</span> <span class="fl">1</span> <span class="op">/</span> <span class="va">df.residual</span><span class="op">)</span>  <span class="co"># R2 variance</span></span>
<span><span class="va">r2s</span></span>
<span><span class="co">## # A tibble: 5 × 6</span></span>
<span><span class="co">## # Groups:   m [5]</span></span>
<span><span class="co">##   m     adj.r.squared df.residual     R     Q      se</span></span>
<span><span class="co">##   &lt;chr&gt;         &lt;dbl&gt;       &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;</span></span>
<span><span class="co">## 1 imp1          0.643         117 0.802  1.10 0.00855</span></span>
<span><span class="co">## 2 imp2          0.648         117 0.805  1.11 0.00855</span></span>
<span><span class="co">## 3 imp3          0.652         117 0.807  1.12 0.00855</span></span>
<span><span class="co">## 4 imp4          0.660         117 0.812  1.13 0.00855</span></span>
<span><span class="co">## 5 imp5          0.654         117 0.808  1.12 0.00855</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Step 2: combine the results using Rubin's rules (mi.meld()), inverse transform</span></span>
<span><span class="co"># the value, and square it</span></span>
<span></span>
<span><span class="co"># Meld the R2 values with mi.meld()</span></span>
<span><span class="va">Q_melded</span> <span class="op">&lt;-</span> <span class="fu">mi.meld</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">r2s</span><span class="op">$</span><span class="va">Q</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">r2s</span><span class="op">$</span><span class="va">se</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Inverse transform Q to R and square it</span></span>
<span><span class="va">r2_melded</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fl">2</span> <span class="op">*</span> <span class="va">Q_melded</span><span class="op">$</span><span class="va">q.mi</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="fl">2</span> <span class="op">*</span> <span class="va">Q_melded</span><span class="op">$</span><span class="va">q.mi</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span></span>
<span><span class="va">r2_melded</span></span>
<span><span class="co">##       [,1]</span></span>
<span><span class="co">## [1,] 0.651</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The correctly pooled/melded <span class="math inline">\(R^2\)</span> is thus 0.651. Neat.</p>
<p>How does this compare to just the average of all the <span class="math inline">\(R^2\)</span>s from all the imputations?</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">r2s_avg</span> <span class="op">&lt;-</span> <span class="va">models_imputations</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ungroup</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span> </span>
<span>  <span class="fu">unnest</span><span class="op">(</span><span class="va">glance</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">summarize</span><span class="op">(</span>adj.r.squared_avg <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">adj.r.squared</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">pull</span><span class="op">(</span><span class="va">adj.r.squared_avg</span><span class="op">)</span></span>
<span><span class="va">r2s_avg</span></span>
<span><span class="co">## [1] 0.651</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The incorrectly averaged <span class="math inline">\(R^2\)</span> is 0.651, which is basically identical to the correctly melded 0.651. This is probably because the models from the five imputed models are already fairly similar—there might be more variance in <span class="math inline">\(R^2\)</span> in data that’s less neat. But for this situation, the two approaches are essentially the same. Other model diagnostics like the F-statistic can probably be pooled just with averages as well. I haven’t found any specific algorithms for melding them with fancy math.</p>
<p>So, in summary, combine the coefficients and standard errors from multiply imputed models with <code>mi.meld()</code> and combine other model parameters like <span class="math inline">\(R^2\)</span> either with Harel’s fancy method or by simply averaging them.</p>


<!-- -->


</main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.andrewheiss\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><script src="https://giscus.app/client.js" data-repo="andrewheiss/ath-quarto" data-repo-id="R_kgDOIg6EJQ" data-category="Blog comments" data-category-id="DIC_kwDOIg6EJc4CSz92" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script><input type="hidden" id="giscus-base-theme" value="light"><input type="hidden" id="giscus-alt-theme" value="dark"><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb14" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Meld regression output from multiple imputations with tidyverse</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2018-03-07</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> Use tidyverse functions to correctly meld and pool multiply imputed model output.</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span><span class="co"> </span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">  - r</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">  - imputation</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">  - tidyverse</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="in">```{r include=FALSE}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::opts_chunk$set(fig.width = 5, fig.height = 4, fig.align = "center", </span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="in">                      fig.retina = 3, out.width = "90%", collapse = TRUE)</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="in">options(digits = 3, width = 90)</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="in">options(dplyr.summarise.inform = FALSE)</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>&lt;span class="small"&gt;(<span class="co">[</span><span class="ot">See this notebook on GitHub</span><span class="co">](https://github.com/andrewheiss/amelia-tidy-melding)</span>)&lt;/span&gt;</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>Missing data can significantly influence the results of normal regression models, since the default in R and most other statistical packages is to throw away any rows with missing variables. To avoid unnecessarily throwing out data, it's helpful to impute missing values. One of the best ways to do this is to build a separate regression model to make predictions that fill in the gaps in data. This isn't always accurate, so it's best to make many iterations of predictions (in imputation parlance, $m$ is the number of imputations done to a dataset). After making $m$ datasets, you can use this data by (1) running statistical tests on each imputation individually and then (2) pooling those results into a single number. The <span class="co">[</span><span class="ot">excellent Amelia vignette</span><span class="co">](https://cran.r-project.org/web/packages/Amelia/vignettes/amelia.pdf)</span> details the theory and mechanics of how to use multiple imputation, and it's a fantastic resource.</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>There are several packages for dealing with missing data in R, including <span class="co">[</span><span class="ot">`mi`</span><span class="co">](https://cran.r-project.org/package=mi)</span>, <span class="co">[</span><span class="ot">`mice`</span><span class="co">](https://cran.r-project.org/package=mice)</span>, and <span class="co">[</span><span class="ot">`Amelia`</span><span class="co">](https://cran.r-project.org/package=Amelia)</span>, and Thomas Leeper has <span class="co">[</span><span class="ot">a short overview of how to use all three</span><span class="co">](http://thomasleeper.com/Rcourse/Tutorials/mi.html)</span>. I'm partial to <span class="co">[</span><span class="ot">Amelia</span><span class="co">](https://gking.harvard.edu/amelia)</span>, since it's designed to work well with time series-cross sectional data and can deal with complicated features like country-year observations. </span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>Because Amelia is written by Gary King, et al., it works with <span class="co">[</span><span class="ot">Zelig</span><span class="co">](https://zeligproject.org/)</span>, a separate framework that's designed to simplify modeling in R. With Zelig + Amelia, you can combine all of the $m$ imputations automatically with whatever Zelig uses for printing model results. I'm not a huge fan of Zelig, though, and I prefer using <span class="in">`lm()`</span>, <span class="in">`glm()`</span>, <span class="in">`stan_glm()`</span>, and gang on my own, thank you very much.</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>However, doing it on my own means there's a little more work involved with combining coefficients and parameters across imputations. Fortunately, the <span class="co">[</span><span class="ot">tidyverse</span><span class="co">](https://www.tidyverse.org/)</span>—specifically its ability to store models within data frames—makes it really easy to deal with models based on imputed data. Here's how to do it using tidy functions. The code for this whole process can be greatly simplified in real life. You technically don't need all these intermediate steps, though they're helpful for seeing what's going on behind the scenes. </span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>We'll start by working with some basic example imputed data frame from Amelia's built-in data. We create 5 imputed datasets defining countries and years as cross sections and time series, and we log GDP per capita in the predictive model:</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="in">```{r load-libraries-impute, warning=FALSE, message=FALSE}</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a><span class="in">library(tidyverse)</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="in">library(Amelia)</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="in">library(broom)</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(1234)</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a><span class="in">data(africa)</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="in">imp_amelia &lt;- amelia(x = africa, m = 5, cs = "country", ts = "year", </span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="in">                     logs = "gdp_pc", p2s = 0)</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>The resulting object contains a list of data frames, and each imputed dataset is stored in a list slot named "imputations" or <span class="in">`imp_amelia$imputations`</span>. We can combine these all into one big data frame with <span class="in">`bind_rows()`</span>, group by the imputation number ($m$), and nest them into imputation-specific rows:</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="in">```{r combine-imputations}</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a><span class="in"># unclass() is necessary because bind_rows() will complain when dealing with</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a><span class="in"># lists with the "amelia" class, which is what amelia() returns</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a><span class="in">all_imputations &lt;- bind_rows(unclass(imp_amelia$imputations), .id = "m") %&gt;%</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(m) %&gt;%</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a><span class="in">  nest()</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a><span class="in">all_imputations</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>With this nested data, we can use <span class="in">`purrr::map()`</span> to run models and return tidy summaries of those models directly in the data frame:</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a><span class="in">```{r imputation-models}</span></span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a><span class="in">models_imputations &lt;- all_imputations %&gt;%</span></span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(model = data %&gt;% map(~ lm(gdp_pc ~ trade + civlib, data = .)),</span></span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a><span class="in">         tidied = model %&gt;% map(~ tidy(., conf.int = TRUE)),</span></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a><span class="in">         glance = model %&gt;% map(~ glance(.)))</span></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a><span class="in">models_imputations</span></span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>Having the models structured like this makes it easy to access coefficients for models from individual imputations, like so:</span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{r check-one-imputation}</span></span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a><span class="in">models_imputations %&gt;%</span></span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(m == "imp1") %&gt;%</span></span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(tidied)</span></span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a>More importantly, we can access the coefficients for all the models, which is essential for combining and averaging the coefficients across all five imputations.</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true" tabindex="-1"></a>Pooling or melding coefficients from many models is a little trickier than just averaging them all together (as delightfully easy as that would be). <span class="co">[</span><span class="ot">Donald Rubin (1987)</span><span class="co">](https://doi.org/10.1002/9780470316696)</span> outlines an algorithm/set of rules for combining the results from multiply imputed datasets that reflects the averages and accounts for differences in standard errors. Rubin's rules are essentially a fancier, more robust way of averaging coefficients and other quantities of interest across imputations.</span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true" tabindex="-1"></a>Amelia has a built-in function for using Rubin's rules named <span class="in">`mi.meld()`</span> that accepts two m-by-k matrices (one for coefficients and one for standard errors) like so:</span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true" tabindex="-1"></a><span class="in">```text</span></span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true" tabindex="-1"></a><span class="in">      coef1  coef2  coefn</span></span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true" tabindex="-1"></a><span class="in">imp1  x      x      x</span></span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true" tabindex="-1"></a><span class="in">imp2  x      x      x</span></span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true" tabindex="-1"></a><span class="in">impn  x      x      x</span></span>
<span id="cb14-85"><a href="#cb14-85" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-86"><a href="#cb14-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-87"><a href="#cb14-87" aria-hidden="true" tabindex="-1"></a>We can use some dplyr/tidyr magic to wrangle the regression results into this form:</span>
<span id="cb14-88"><a href="#cb14-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-89"><a href="#cb14-89" aria-hidden="true" tabindex="-1"></a><span class="in">```{r matrix-wrangle}</span></span>
<span id="cb14-90"><a href="#cb14-90" aria-hidden="true" tabindex="-1"></a><span class="in"># Create a wide data frame of just the coefficients and standard errors</span></span>
<span id="cb14-91"><a href="#cb14-91" aria-hidden="true" tabindex="-1"></a><span class="in">params &lt;- models_imputations %&gt;%</span></span>
<span id="cb14-92"><a href="#cb14-92" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(tidied) %&gt;%</span></span>
<span id="cb14-93"><a href="#cb14-93" aria-hidden="true" tabindex="-1"></a><span class="in">  select(m, term, estimate, std.error) %&gt;%</span></span>
<span id="cb14-94"><a href="#cb14-94" aria-hidden="true" tabindex="-1"></a><span class="in">  gather(key, value, estimate, std.error) %&gt;%</span></span>
<span id="cb14-95"><a href="#cb14-95" aria-hidden="true" tabindex="-1"></a><span class="in">  spread(term, value) %&gt;% </span></span>
<span id="cb14-96"><a href="#cb14-96" aria-hidden="true" tabindex="-1"></a><span class="in">  ungroup()</span></span>
<span id="cb14-97"><a href="#cb14-97" aria-hidden="true" tabindex="-1"></a><span class="in">params</span></span>
<span id="cb14-98"><a href="#cb14-98" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-99"><a href="#cb14-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-100"><a href="#cb14-100" aria-hidden="true" tabindex="-1"></a><span class="in">```{r matrix-coefs, message=FALSE}</span></span>
<span id="cb14-101"><a href="#cb14-101" aria-hidden="true" tabindex="-1"></a><span class="in"># Extract just the coefficients</span></span>
<span id="cb14-102"><a href="#cb14-102" aria-hidden="true" tabindex="-1"></a><span class="in">just_coefs &lt;- params %&gt;%</span></span>
<span id="cb14-103"><a href="#cb14-103" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(key == "estimate") %&gt;%</span></span>
<span id="cb14-104"><a href="#cb14-104" aria-hidden="true" tabindex="-1"></a><span class="in">  select(-m, -key)</span></span>
<span id="cb14-105"><a href="#cb14-105" aria-hidden="true" tabindex="-1"></a><span class="in">just_coefs</span></span>
<span id="cb14-106"><a href="#cb14-106" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-107"><a href="#cb14-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-108"><a href="#cb14-108" aria-hidden="true" tabindex="-1"></a><span class="in">```{r matrix-ses, message=FALSE}</span></span>
<span id="cb14-109"><a href="#cb14-109" aria-hidden="true" tabindex="-1"></a><span class="in"># Extract just the standard errors</span></span>
<span id="cb14-110"><a href="#cb14-110" aria-hidden="true" tabindex="-1"></a><span class="in">just_ses &lt;- params %&gt;%</span></span>
<span id="cb14-111"><a href="#cb14-111" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(key == "std.error") %&gt;%</span></span>
<span id="cb14-112"><a href="#cb14-112" aria-hidden="true" tabindex="-1"></a><span class="in">  select(-m, -key)</span></span>
<span id="cb14-113"><a href="#cb14-113" aria-hidden="true" tabindex="-1"></a><span class="in">just_ses</span></span>
<span id="cb14-114"><a href="#cb14-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-115"><a href="#cb14-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-116"><a href="#cb14-116" aria-hidden="true" tabindex="-1"></a>We can then use these matrices in <span class="in">`mi.meld()`</span>, which returns a list with two slots—<span class="in">`q.mi`</span> and <span class="in">`se.mi`</span>:</span>
<span id="cb14-117"><a href="#cb14-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-120"><a href="#cb14-120" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb14-121"><a href="#cb14-121" aria-hidden="true" tabindex="-1"></a>coefs_melded <span class="ot">&lt;-</span> <span class="fu">mi.meld</span>(just_coefs, just_ses)</span>
<span id="cb14-122"><a href="#cb14-122" aria-hidden="true" tabindex="-1"></a>coefs_melded</span>
<span id="cb14-123"><a href="#cb14-123" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-124"><a href="#cb14-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-125"><a href="#cb14-125" aria-hidden="true" tabindex="-1"></a>Armed with these, we can create our regression summary table with some more dplyr wizardry. To calculate the p-value and confidence intervals, we need to extract the degrees of freedom from one of the imputed models</span>
<span id="cb14-126"><a href="#cb14-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-129"><a href="#cb14-129" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb14-130"><a href="#cb14-130" aria-hidden="true" tabindex="-1"></a>model_degree_freedom <span class="ot">&lt;-</span> models_imputations <span class="sc">%&gt;%</span></span>
<span id="cb14-131"><a href="#cb14-131" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(glance) <span class="sc">%&gt;%</span></span>
<span id="cb14-132"><a href="#cb14-132" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(m <span class="sc">==</span> <span class="st">"imp1"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb14-133"><a href="#cb14-133" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(df.residual)</span>
<span id="cb14-134"><a href="#cb14-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-135"><a href="#cb14-135" aria-hidden="true" tabindex="-1"></a>melded_summary <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">cbind</span>(<span class="fu">t</span>(coefs_melded<span class="sc">$</span>q.mi),</span>
<span id="cb14-136"><a href="#cb14-136" aria-hidden="true" tabindex="-1"></a>                                      <span class="fu">t</span>(coefs_melded<span class="sc">$</span>se.mi))) <span class="sc">%&gt;%</span></span>
<span id="cb14-137"><a href="#cb14-137" aria-hidden="true" tabindex="-1"></a>  magrittr<span class="sc">::</span><span class="fu">set_colnames</span>(<span class="fu">c</span>(<span class="st">"estimate"</span>, <span class="st">"std.error"</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb14-138"><a href="#cb14-138" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">term =</span> <span class="fu">rownames</span>(.)) <span class="sc">%&gt;%</span></span>
<span id="cb14-139"><a href="#cb14-139" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(term, <span class="fu">everything</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb14-140"><a href="#cb14-140" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">statistic =</span> estimate <span class="sc">/</span> std.error,</span>
<span id="cb14-141"><a href="#cb14-141" aria-hidden="true" tabindex="-1"></a>         <span class="at">conf.low =</span> estimate <span class="sc">+</span> std.error <span class="sc">*</span> <span class="fu">qt</span>(<span class="fl">0.025</span>, model_degree_freedom),</span>
<span id="cb14-142"><a href="#cb14-142" aria-hidden="true" tabindex="-1"></a>         <span class="at">conf.high =</span> estimate <span class="sc">+</span> std.error <span class="sc">*</span> <span class="fu">qt</span>(<span class="fl">0.975</span>, model_degree_freedom),</span>
<span id="cb14-143"><a href="#cb14-143" aria-hidden="true" tabindex="-1"></a>         <span class="at">p.value =</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fu">pt</span>(<span class="fu">abs</span>(statistic), model_degree_freedom, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>))</span>
<span id="cb14-144"><a href="#cb14-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-145"><a href="#cb14-145" aria-hidden="true" tabindex="-1"></a>melded_summary</span>
<span id="cb14-146"><a href="#cb14-146" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-147"><a href="#cb14-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-148"><a href="#cb14-148" aria-hidden="true" tabindex="-1"></a>Hooray! Correctly melded coefficients and standard errors!</span>
<span id="cb14-149"><a href="#cb14-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-150"><a href="#cb14-150" aria-hidden="true" tabindex="-1"></a>But what do we do about the other model details, like $R^2$ and the F-statistic? How do we report those?</span>
<span id="cb14-151"><a href="#cb14-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-152"><a href="#cb14-152" aria-hidden="true" tabindex="-1"></a>According to <span class="co">[</span><span class="ot">a post on the Amelia mailing list</span><span class="co">](https://lists.gking.harvard.edu/pipermail/amelia/2016-July/001249.html)</span>, there are two ways. First, we can use a fancy method for combining $R^2$ and adjusted $R^2$ described by <span class="co">[</span><span class="ot">Ofer Harel (2009)</span><span class="co">](https://doi.org/10.1080/02664760802553000)</span>. Second, we can just take the average of the $R^2$s from all the imputed models. The results should be roughly the same.</span>
<span id="cb14-153"><a href="#cb14-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-154"><a href="#cb14-154" aria-hidden="true" tabindex="-1"></a>Harel's method involves two steps:</span>
<span id="cb14-155"><a href="#cb14-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-156"><a href="#cb14-156" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>In each complete data set, calculate the $R^2$, take its square root ($R$), transform $R$ with a Fisher z-transformation ($Q = \frac{1}{2} \log_{e}(\frac{1 + R}{1 - R})$), and calculate the variance of $R^2$ (which is $\frac{1}{\text{degrees of freedom}}$)</span>
<span id="cb14-157"><a href="#cb14-157" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Meld the resulting $Q$ and variance using Rubin's rules (<span class="in">`mi.meld()`</span>; this creates $Q_a$), undo the z-transformation ($R_a = (\frac{-1 + \exp(2Q_a)}{1 + \exp(2Q_a)})^2$), and square it ($R_a^2$)</span>
<span id="cb14-158"><a href="#cb14-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-159"><a href="#cb14-159" aria-hidden="true" tabindex="-1"></a>That looks complicated, but it's fairly easy with some dplyr magic. Here's how to do it for adjusted $R^2$ (the same process works for regular $R^2$ too):</span>
<span id="cb14-160"><a href="#cb14-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-161"><a href="#cb14-161" aria-hidden="true" tabindex="-1"></a><span class="in">```{r r2-meld-step1}</span></span>
<span id="cb14-162"><a href="#cb14-162" aria-hidden="true" tabindex="-1"></a><span class="in"># Step 1: in each complete data set, calculate R2, take its square root,</span></span>
<span id="cb14-163"><a href="#cb14-163" aria-hidden="true" tabindex="-1"></a><span class="in"># transform it with Fisher z-transformation, and calculate the variance of R2\</span></span>
<span id="cb14-164"><a href="#cb14-164" aria-hidden="true" tabindex="-1"></a><span class="in">r2s &lt;- models_imputations %&gt;%</span></span>
<span id="cb14-165"><a href="#cb14-165" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(glance) %&gt;%</span></span>
<span id="cb14-166"><a href="#cb14-166" aria-hidden="true" tabindex="-1"></a><span class="in">  select(m, adj.r.squared, df.residual) %&gt;%</span></span>
<span id="cb14-167"><a href="#cb14-167" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(R = sqrt(adj.r.squared),  # Regular R</span></span>
<span id="cb14-168"><a href="#cb14-168" aria-hidden="true" tabindex="-1"></a><span class="in">         Q = 0.5 * log((R + 1) / (1 - R)),  # Fisher z-transformation</span></span>
<span id="cb14-169"><a href="#cb14-169" aria-hidden="true" tabindex="-1"></a><span class="in">         se = 1 / df.residual)  # R2 variance</span></span>
<span id="cb14-170"><a href="#cb14-170" aria-hidden="true" tabindex="-1"></a><span class="in">r2s</span></span>
<span id="cb14-171"><a href="#cb14-171" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-172"><a href="#cb14-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-173"><a href="#cb14-173" aria-hidden="true" tabindex="-1"></a><span class="in">```{r rd-meld-step2}</span></span>
<span id="cb14-174"><a href="#cb14-174" aria-hidden="true" tabindex="-1"></a><span class="in"># Step 2: combine the results using Rubin's rules (mi.meld()), inverse transform</span></span>
<span id="cb14-175"><a href="#cb14-175" aria-hidden="true" tabindex="-1"></a><span class="in"># the value, and square it</span></span>
<span id="cb14-176"><a href="#cb14-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-177"><a href="#cb14-177" aria-hidden="true" tabindex="-1"></a><span class="in"># Meld the R2 values with mi.meld()</span></span>
<span id="cb14-178"><a href="#cb14-178" aria-hidden="true" tabindex="-1"></a><span class="in">Q_melded &lt;- mi.meld(as.matrix(r2s$Q), as.matrix(r2s$se))</span></span>
<span id="cb14-179"><a href="#cb14-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-180"><a href="#cb14-180" aria-hidden="true" tabindex="-1"></a><span class="in"># Inverse transform Q to R and square it</span></span>
<span id="cb14-181"><a href="#cb14-181" aria-hidden="true" tabindex="-1"></a><span class="in">r2_melded &lt;- ((exp(2 * Q_melded$q.mi) - 1) / (1 + exp(2 * Q_melded$q.mi)))^2</span></span>
<span id="cb14-182"><a href="#cb14-182" aria-hidden="true" tabindex="-1"></a><span class="in">r2_melded</span></span>
<span id="cb14-183"><a href="#cb14-183" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-184"><a href="#cb14-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-185"><a href="#cb14-185" aria-hidden="true" tabindex="-1"></a>The correctly pooled/melded $R^2$ is thus <span class="in">`r r2_melded %&gt;% round(4)`</span>. Neat.</span>
<span id="cb14-186"><a href="#cb14-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-187"><a href="#cb14-187" aria-hidden="true" tabindex="-1"></a>How does this compare to just the average of all the $R^2$s from all the imputations?</span>
<span id="cb14-188"><a href="#cb14-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-189"><a href="#cb14-189" aria-hidden="true" tabindex="-1"></a><span class="in">```{r r2-avg}</span></span>
<span id="cb14-190"><a href="#cb14-190" aria-hidden="true" tabindex="-1"></a><span class="in">r2s_avg &lt;- models_imputations %&gt;%</span></span>
<span id="cb14-191"><a href="#cb14-191" aria-hidden="true" tabindex="-1"></a><span class="in">  ungroup() %&gt;% </span></span>
<span id="cb14-192"><a href="#cb14-192" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(glance) %&gt;%</span></span>
<span id="cb14-193"><a href="#cb14-193" aria-hidden="true" tabindex="-1"></a><span class="in">  summarize(adj.r.squared_avg = mean(adj.r.squared)) %&gt;%</span></span>
<span id="cb14-194"><a href="#cb14-194" aria-hidden="true" tabindex="-1"></a><span class="in">  pull(adj.r.squared_avg)</span></span>
<span id="cb14-195"><a href="#cb14-195" aria-hidden="true" tabindex="-1"></a><span class="in">r2s_avg</span></span>
<span id="cb14-196"><a href="#cb14-196" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb14-197"><a href="#cb14-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-198"><a href="#cb14-198" aria-hidden="true" tabindex="-1"></a>The incorrectly averaged $R^2$ is <span class="in">`r r2s_avg %&gt;% round(4)`</span>, which is basically identical to the correctly melded <span class="in">`r r2_melded %&gt;% round(4)`</span>. This is probably because the models from the five imputed models are already fairly similar—there might be more variance in $R^2$ in data that's less neat. But for this situation, the two approaches are essentially the same. Other model diagnostics like the F-statistic can probably be pooled just with averages as well. I haven't found any specific algorithms for melding them with fancy math. </span>
<span id="cb14-199"><a href="#cb14-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-200"><a href="#cb14-200" aria-hidden="true" tabindex="-1"></a>So, in summary, combine the coefficients and standard errors from multiply imputed models with <span class="in">`mi.meld()`</span> and combine other model parameters like $R^2$ either with Harel's fancy method or by simply averaging them.</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><span class="faux-block">Forked from <a href="https://www.andrewheiss.com/">Andrew Heiss</a></span> # <span class="faux-block"><a href="https://github.com/andrewheiss/ath-quarto">View the source at <i class="fa-brands fa-github" aria-label="github"></i> GitHub</a></span></p>
</div>
  </div>
</footer>


</body></html>